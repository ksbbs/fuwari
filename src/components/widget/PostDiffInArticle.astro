---
---

<script>
	import * as Diff from "diff";

	const NOTIFICATION_STATE_KEY = "fuwari-notification-state";
	const DEBUG_PARAM_KEY = "__diff_debug";
	const DEBUG_STATE_KEY = "fuwari-diff-debug-state";
	const CONTEXT_LINES = 2;

	function normalizeGuid(guid, link) {
		const value = (guid || link || "").trim();
		if (!value) return "";
		try {
			const url = new URL(value, window.location.origin);
			return `${url.pathname}${url.search}${url.hash}`;
		} catch {
			return value;
		}
	}

	function getRelativePath(absoluteUrl) {
		try {
			const url = new URL(absoluteUrl, window.location.origin);
			return `${url.pathname}${url.search}${url.hash}`;
		} catch {
			return absoluteUrl;
		}
	}

	function normalizePathname(pathname) {
		const p = String(pathname || "");
		if (!p) return "/";
		const noQueryHash = p.split("#")[0].split("?")[0];
		if (noQueryHash.length > 1) return noQueryHash.replace(/\/+$/, "");
		return "/";
	}

	function clearInlineDiff(container) {
		container.querySelectorAll("[data-post-inline-diff-inline]").forEach((el) => {
			if (!(el instanceof HTMLElement)) return;
			const kind = el.getAttribute("data-post-inline-diff-inline") || "";
			if (kind === "anchor") {
				el.remove();
				return;
			}
			if (kind === "add") {
				el.remove();
				return;
			}
			const text = document.createTextNode(el.textContent || "");
			el.replaceWith(text);
		});

		container.querySelectorAll("[data-post-inline-diff]").forEach((el) => el.remove());
		container
			.querySelectorAll("[data-post-inline-diff-add-target]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-add-target"));
		container.querySelectorAll(".post-inline-diff-add-target").forEach((el) => el.classList.remove("post-inline-diff-add-target"));
		container
			.querySelectorAll("[data-post-inline-diff-add-target-img]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-add-target-img"));
		container.querySelectorAll(".post-inline-diff-add-target-img").forEach((el) => el.classList.remove("post-inline-diff-add-target-img"));
		container
			.querySelectorAll("[data-post-inline-diff-del-target]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-del-target"));
		container.querySelectorAll(".post-inline-diff-del-target").forEach((el) => el.classList.remove("post-inline-diff-del-target"));
		container
			.querySelectorAll("[data-post-inline-diff-del-target-img]")
			.forEach((el) => el.removeAttribute("data-post-inline-diff-del-target-img"));
		container.querySelectorAll(".post-inline-diff-del-target-img").forEach((el) => el.classList.remove("post-inline-diff-del-target-img"));
	}

	function buildRows(diffParts) {
		/** @type {{type: 'add'|'del'|'ctx', text: string}[]} */
		const rows = [];

		for (const part of diffParts) {
			const type = part?.added ? "add" : part?.removed ? "del" : "ctx";
			const value = String(part?.value ?? "");
			const lines = value.split("\n");
			if (lines.length > 0 && lines[lines.length - 1] === "") lines.pop();
			for (const line of lines) rows.push({ type, text: line });
		}

		return rows;
	}

	function sliceWithContext(rows) {
		const changeIndexes = [];
		for (let i = 0; i < rows.length; i += 1) {
			if (rows[i].type !== "ctx") changeIndexes.push(i);
		}
		if (changeIndexes.length === 0) return [];

		const keep = new Array(rows.length).fill(false);
		for (const idx of changeIndexes) {
			const start = Math.max(0, idx - CONTEXT_LINES);
			const end = Math.min(rows.length - 1, idx + CONTEXT_LINES);
			for (let i = start; i <= end; i += 1) keep[i] = true;
		}

		/** @type {(typeof rows[number] | {type: 'gap', text: string})[]} */
		const out = [];
		let inGap = false;
		for (let i = 0; i < rows.length; i += 1) {
			if (keep[i]) {
				out.push(rows[i]);
				inGap = false;
				continue;
			}
			if (!inGap) {
				out.push({ type: "gap", text: "…" });
				inGap = true;
			}
		}

		return out;
	}

	function toHunks(rowsWithGaps) {
		/** @type {{type: 'add'|'del'|'ctx', text: string}[][]} */
		const hunks = [];
		/** @type {{type: 'add'|'del'|'ctx', text: string}[]} */
		let current = [];

		for (const row of rowsWithGaps) {
			if (row.type === "gap") {
				if (current.length) hunks.push(current);
				current = [];
				continue;
			}
			current.push(row);
		}
		if (current.length) hunks.push(current);
		return hunks;
	}

	function normalizeLineText(text) {
		return String(text ?? "")
			.replace(/\r\n/g, "\n")
			.replace(/\r/g, "\n")
			.replace(/\u00A0/g, " ")
			.replace(/[ \t]*\n[ \t]*/g, " ")
			.replace(/[ \t]{2,}/g, " ")
			.replace(/[ \t]+$/g, "")
			.trim();
	}

	function extractImgSrc(line) {
		const s = String(line ?? "");
		const m = s.match(/<img[^>]*\s(?:src|data-src)=["']([^"']+)["']/i);
		return m?.[1] ? String(m[1]).trim() : null;
	}

	function stripHtmlLine(line) {
		const tmp = document.createElement("div");
		tmp.innerHTML = String(line ?? "");
		return tmp.textContent || tmp.innerText || "";
	}

	function normalizeForMatch(line) {
		const text = normalizeLineText(stripHtmlLine(line));
		if (text) return { kind: "text", value: text };
		const imgSrc = extractImgSrc(line);
		if (imgSrc) return { kind: "img", value: imgSrc };
		const raw = normalizeLineText(line);
		if (raw) return { kind: "text", value: raw };
		return { kind: "none", value: "" };
	}

	function findImgBySrc(container, src) {
		const norm = String(src || "").trim();
		if (!norm) return null;
		const imgs = container.querySelectorAll("img");
		for (const img of imgs) {
			if (!(img instanceof HTMLImageElement)) continue;
			const cand = img.getAttribute("src") || img.getAttribute("data-src") || "";
			if (cand === norm) return img;
			if (cand && norm && (cand.includes(norm) || norm.includes(cand))) return img;
		}
		return null;
	}

	function getBlockList(container) {
		return Array.from(container.querySelectorAll("p, li, blockquote, pre, h1, h2, h3, h4, h5, h6, img")).filter((el) => el instanceof HTMLElement);
	}

	function findContextBefore(container, hunk, rowIndex) {
		for (let i = rowIndex - 1; i >= 0; i -= 1) {
			const row = hunk[i];
			if (row?.type !== "ctx") continue;
			const el = findBlockByText(container, row.text);
			if (el) return el;
		}
		return null;
	}

	function findContextAfter(container, hunk, rowIndex) {
		for (let i = rowIndex + 1; i < hunk.length; i += 1) {
			const row = hunk[i];
			if (row?.type !== "ctx") continue;
			const el = findBlockByText(container, row.text);
			if (el) return el;
		}
		return null;
	}

	function lineExistsInArticle(container, line) {
		const key = normalizeForMatch(line);
		if (key.kind === "img") return !!findImgBySrc(container, key.value);
		if (key.kind !== "text") return false;
		return !!findBlockByText(container, line);
	}

	function findBlockByText(container, line) {
		const key = normalizeForMatch(line);
		if (key.kind !== "text") return null;
		const needle = key.value.slice(0, 48);
		const blocks = container.querySelectorAll("p, li, blockquote, pre, h1, h2, h3, h4, h5, h6");
		for (const el of blocks) {
			if (!(el instanceof HTMLElement)) continue;
			if (el.closest(".post-inline-diff-add-line")) continue;
			if (el.closest(".post-inline-diff-del-line")) continue;
			if (el.classList.contains("post-inline-diff-del-target")) continue;
			const content = el.textContent || "";
			if (!normalizeLineText(content).includes(needle)) continue;
			return el;
		}

		return null;
	}

	function findAnchorElement(container, hunk) {
		const pick = (row) => String(row?.text ?? "").trim();
		const ctx = hunk.find((r) => r.type === "ctx" && pick(r).length >= 6);
		const anchorLine = ctx?.text ?? ""; 
		if (!anchorLine) return null;
		
		const key = normalizeForMatch(anchorLine);
		if (key.kind === "img") return findImgBySrc(container, key.value);
		return findBlockByText(container, anchorLine);
	}

	function createDeletionNode(text, includeAnchor, useListItem) {
		const el = document.createElement(useListItem ? "li" : "div");
		el.setAttribute("data-post-inline-diff", "1");
		el.className = "post-inline-diff-del-line";

		if (includeAnchor) {
			const anchor = document.createElement("span");
			anchor.id = "post-diff";
			anchor.setAttribute("data-post-inline-diff", "1");
			el.appendChild(anchor);
		}

		const del = document.createElement("del");
		const raw = normalizeLineText(text);
		if (shouldRenderLineAsHtml(raw)) del.innerHTML = " " + sanitizeHtmlFragment(raw);
		else del.textContent = ` ${raw}`;

		el.appendChild(del);
		return el;
	}

	function sanitizeHtmlFragment(html) {
		const parser = new DOMParser();
		const doc = parser.parseFromString(`<div>${String(html || "")}</div>`, "text/html");
		const root = doc.body.firstElementChild;
		if (!root) return String(html || "");

		const scripts = root.querySelectorAll("script, iframe, object, embed, style");
		scripts.forEach(el => el.remove());

		const all = root.querySelectorAll("*");
		all.forEach(el => {
			const attrs = Array.from(el.attributes);
			for (const attr of attrs) {
				if (attr.name.startsWith("on")) el.removeAttribute(attr.name);
			}
		});

		return root.innerHTML;
	}

	function shouldRenderLineAsHtml(line) {
		const t = String(line || "").trim();
		return /<[a-z][\s\S]*>/i.test(t) || /<\/[a-z][\s\S]*>/i.test(t);
	}

	function createAdditionNode(text, includeAnchor, useListItem) {
		const el = document.createElement(useListItem ? "li" : "div");
		el.setAttribute("data-post-inline-diff", "1");
		el.className = "post-inline-diff-add-line";

		if (includeAnchor) {
			const anchor = document.createElement("span");
			anchor.id = "post-diff";
			anchor.setAttribute("data-post-inline-diff", "1");
			el.appendChild(anchor);
		}

		const content = document.createElement("div");
		content.className = "post-inline-diff-add-content";

		const raw = String(text ?? "").trim();
		if (shouldRenderLineAsHtml(raw)) content.innerHTML = sanitizeHtmlFragment(raw);
		else content.textContent = raw;

		el.appendChild(content);
		return el;
	}

	function insertAfter(node, ref) {
		const parent = ref?.parentNode;
		if (!parent) return false;
		parent.insertBefore(node, ref.nextSibling);
		return true;
	}

	function parseHtmlSingleElement(html) {
		const parser = new DOMParser();
		const doc = parser.parseFromString(`<div>${String(html || "")}</div>`, "text/html");
		return doc.body.firstElementChild?.firstElementChild;
	}

	function applyInlineTextDiff(targetTextNodes, oldText, newText, anchorState) {
		const nodes = Array.isArray(targetTextNodes) ? targetTextNodes : [targetTextNodes];
		const head = nodes[0];
		if (!(head instanceof Text)) return false;
		for (let i = 1; i < nodes.length; i += 1) {
			const n = nodes[i];
			if (n instanceof Node) n.parentNode?.removeChild(n);
		}
		const parts = Diff.diffChars(String(oldText || ""), String(newText || ""));
		const frag = document.createDocumentFragment();
		for (const part of parts) {
			if (part.added || part.removed) {
				if (!anchorState.inserted) {
					const anchor = document.createElement("span");
					anchor.id = "post-diff";
					anchor.setAttribute("data-post-inline-diff-inline", "anchor");
					frag.appendChild(anchor);
					anchorState.inserted = true;
				}
				const span = document.createElement("span");
				span.className = part.added ? "post-inline-diff-add-target" : "post-inline-diff-del-target";
				span.setAttribute("data-post-inline-diff-inline", part.added ? "add" : "del");
				span.textContent = String(part.value ?? "");
				frag.appendChild(span);
				continue;
			}
			frag.appendChild(document.createTextNode(String(part.value ?? "")));
		}
		head.parentNode?.replaceChild(frag, head);
		return parts.some((p) => p.added || p.removed);
	}

	function tryApplyInlineReplace(targetEl, oldHtml, newHtml, anchorState) {
		const oldEl = parseHtmlSingleElement(oldHtml);
		const newEl = parseHtmlSingleElement(newHtml);
		if (!(oldEl instanceof HTMLElement) || !(newEl instanceof HTMLElement)) return false;
		if (oldEl.tagName !== newEl.tagName) return false;
		if (targetEl.tagName !== oldEl.tagName) return false;
		if (normalizeLineText(oldEl.textContent || "") !== normalizeLineText(targetEl.textContent || "")) return false;

		const tokenize = (el) => {
			const out = [];
			let buf = "";
			/** @type {Text[]} */
			let bufNodes = [];
			for (const n of Array.from(el.childNodes)) {
				if (n.nodeType === Node.TEXT_NODE) {
					buf += n.nodeValue || "";
					bufNodes.push(n);
					continue;
				}
				if (bufNodes.length) {
					out.push({ kind: "text", text: buf, nodes: bufNodes });
					buf = "";
					bufNodes = [];
				}
				if (n.nodeType === Node.ELEMENT_NODE) out.push({ kind: "el", node: n });
				else return null;
			}
			if (bufNodes.length) out.push({ kind: "text", text: buf, nodes: bufNodes });
			return out;
		};

		const stack = [{ a: oldEl, b: newEl, t: targetEl }];
		let changed = false;

		while (stack.length) {
			const { a, b, t } = stack.pop();
			const aTok = tokenize(a);
			const bTok = tokenize(b);
			const tTok = tokenize(t);
			if (!aTok || !bTok || !tTok) return false;
			if (aTok.length !== bTok.length || aTok.length !== tTok.length) return false;

			for (let i = aTok.length - 1; i >= 0; i -= 1) {
				const at = aTok[i];
				const bt = bTok[i];
				const tt = tTok[i];
				if (at.kind !== bt.kind || at.kind !== tt.kind) return false;
				if (at.kind === "text") {
					const did = applyInlineTextDiff(tt.nodes, at.text, bt.text, anchorState);
					if (did) changed = true;
					continue;
				}
				if (at.kind === "el") {
					if (at.node.tagName !== bt.node.tagName || at.node.tagName !== tt.node.tagName) return false;
					stack.push({ a: at.node, b: bt.node, t: tt.node });
					continue;
				}
				return false;
			}
		}

		return changed;
	}

	function applyInlineDiff(container, diffParts, isDebug) {
		clearInlineDiff(container);
		const rows = buildRows(diffParts);
		const focused = sliceWithContext(rows);
		const hunks = toHunks(focused);

		const anchorState = { inserted: false };
		for (const hunk of hunks) {
			const insertionPoint = findAnchorElement(container, hunk);
			let idx = 0;
			while (idx < hunk.length) {
				const row = hunk[idx];
				if (idx + 1 < hunk.length) {
					const next = hunk[idx + 1];
					const isReplace = (row.type === "del" && next.type === "add") || (row.type === "add" && next.type === "del");
					if (isReplace) {
						const oldHtml = row.type === "del" ? row.text : next.text;
						const newHtml = row.type === "add" ? row.text : next.text;
						const target = findBlockByText(container, oldHtml);
						if (target instanceof HTMLElement) {
							const applied = tryApplyInlineReplace(target, oldHtml, newHtml, anchorState);
							if (applied) {
								idx += 2;
								continue;
							}
						}
					}
				}

				if (row.type === "add") {
					let endIdx = idx;
					let combinedText = row.text;
					while (endIdx + 1 < hunk.length && hunk[endIdx + 1].type === "add") {
						endIdx++;
						combinedText += "\n" + hunk[endIdx].text;
					}
					const ctxBefore = findContextBefore(container, hunk, idx);
					const ctxAfter = findContextAfter(container, hunk, endIdx);

					const useListItem = (ctxBefore?.tagName === "LI") || (ctxAfter?.tagName === "LI");
					const node = createAdditionNode(combinedText, !anchorState.inserted, useListItem);
					if (!anchorState.inserted) anchorState.inserted = true;

					let inserted = false;
					if (ctxBefore?.parentNode) inserted = insertAfter(node, ctxBefore);
					if (!inserted && ctxAfter?.parentNode) {
						ctxAfter.parentNode.insertBefore(node, ctxAfter);
						inserted = true;
					}
					if (!inserted) {
						if (insertionPoint?.parentNode) insertionPoint.parentNode.insertBefore(node, insertionPoint);
						else container.prepend(node);
					}

					idx = endIdx + 1;
					continue;
				}

				if (row.type !== "del") {
					idx += 1;
					continue;
				}

				const key = normalizeForMatch(row.text);
				if (key.kind === "none") {
					idx += 1;
					continue;
				}

				if (lineExistsInArticle(container, row.text)) {
					if (key.kind === "img") {
						const img = findImgBySrc(container, key.value);
						if (img instanceof HTMLElement) {
							img.classList.add("post-inline-diff-del-target-img");
							img.setAttribute("data-post-inline-diff-del-target-img", "1");
						}
						idx += 1;
						continue;
					}
					const target = findBlockByText(container, row.text);
					if (target instanceof HTMLElement) {
						target.classList.add("post-inline-diff-del-target");
						target.setAttribute("data-post-inline-diff-del-target", "1");
					}
					idx += 1;
					continue;
				}

				const t = key.kind === "img" ? `[图片] ${key.value}` : key.value;

				let inserted = false;

				for (let i = idx - 1; i >= 0; i -= 1) {
					const prev = hunk[i];
					if (prev?.type !== "ctx") continue;
					const ctxEl = findBlockByText(container, prev.text);
					if (!(ctxEl instanceof HTMLElement)) continue;
					const useListItem = ctxEl.tagName === "LI";
					const node = createDeletionNode(t, !anchorState.inserted, useListItem);
					if (!anchorState.inserted) anchorState.inserted = true;
					inserted = insertAfter(node, ctxEl);
					break;
				}

				if (!inserted) {
					for (let i = idx + 1; i < hunk.length; i += 1) {
						const next = hunk[i];
						if (next?.type !== "ctx") continue;
						const ctxEl = findBlockByText(container, next.text);
						if (!(ctxEl instanceof HTMLElement)) continue;
						const useListItem = ctxEl.tagName === "LI";
						const node = createDeletionNode(t, !anchorState.inserted, useListItem);
						if (!anchorState.inserted) anchorState.inserted = true;
						ctxEl.parentNode?.insertBefore(node, ctxEl);
						inserted = true;
						break;
					}
				}

				if (!inserted) {
					const useListItem = insertionPoint?.tagName === "LI";
					const node = createDeletionNode(t, !anchorState.inserted, useListItem);
					if (!anchorState.inserted) anchorState.inserted = true;
					if (insertionPoint?.parentNode) insertionPoint.parentNode.insertBefore(node, insertionPoint);
					else container.prepend(node);
				}

				idx += 1;
			}
		}
	}

	function applySimpleDiff(container, diffParts) {
		container.innerHTML = "";
		const rows = buildRows(diffParts);
		
		for (const row of rows) {
			if (row.type === "ctx") {
				const span = document.createElement("span");
				span.textContent = row.text;
				container.appendChild(span);
			} else if (row.type === "add") {
				const span = document.createElement("span");
				span.className = "post-inline-diff-add-target";
				span.textContent = row.text;
				if (!container.querySelector("#post-diff")) {
					const anchor = document.createElement("span");
					anchor.id = "post-diff";
					container.appendChild(anchor);
				}
				container.appendChild(span);
			} else if (row.type === "del") {
				const span = document.createElement("span");
				span.className = "post-inline-diff-del-target";
				span.textContent = row.text;
				container.appendChild(span);
			}
		}
	}

	function initPostInlineDiff() {
		const sp = new URLSearchParams(window.location.search);
		const isDebug = sp.get(DEBUG_PARAM_KEY) === "1";

		const stateStr = isDebug ? sessionStorage.getItem(DEBUG_STATE_KEY) : localStorage.getItem(NOTIFICATION_STATE_KEY);
		if (!stateStr) {
			return;
		}

		let state;
		try {
			state = JSON.parse(stateStr);
		} catch {
            const content = document.querySelector(".markdown-content");
            if (content instanceof HTMLElement) clearInlineDiff(content);
			return;
		}

		const items = Array.isArray(state?.items) ? state.items : [];
		const currentPath = normalizePathname(window.location.pathname);

		const matched = items.find((post) => {
			if (!post?.isUpdated || !post?.diff) return false;
			const guidPath = normalizePathname(normalizeGuid(post.guid, post.link));
			const linkPath = normalizePathname(getRelativePath(post.link));
			return guidPath === currentPath || linkPath === currentPath;
		});

		const shouldApply = isDebug || sp.get("diff") === "1" || window.location.hash === "#post-diff";

		if (!shouldApply || !matched?.diff) {
            const content = document.querySelector(".markdown-content");
            if (content instanceof HTMLElement) clearInlineDiff(content);
			return;
		}

        const diffType = matched.diffType || 'composite';
        
        let diffData = matched.diff;
        
        if (Array.isArray(diffData)) {
            if (diffType === 'title') diffData = { title: diffData };
            else if (diffType === 'description') diffData = { description: diffData };
            else diffData = { content: diffData };
        } else if (diffData.diff && (diffData.diffType === 'composite' || diffData.diffType === undefined)) {
            diffData = diffData.diff;
        }

        if (diffData.title) {
            const container = document.getElementById('post-title');
            if (container) applySimpleDiff(container, diffData.title);
        }
        
        if (diffData.description) {
            const container = document.getElementById('post-description');
            if (container) applySimpleDiff(container, diffData.description);
        }
        
        if (diffData.content) {
            const container = document.querySelector(".markdown-content");
            if (container) applyInlineDiff(container, diffData.content, isDebug);
        }

		const anchor = document.getElementById("post-diff");
		if (anchor instanceof HTMLElement) anchor.scrollIntoView({ behavior: "smooth", block: "start" });
	}

	document.addEventListener("DOMContentLoaded", initPostInlineDiff);
	document.addEventListener("swup:contentReplaced", initPostInlineDiff);
	window.addEventListener("fuwari:diff-debug-updated", initPostInlineDiff);
</script>

<style is:global>
	.post-inline-diff-add-target {
		text-decoration-line: underline;
		text-decoration-thickness: 2px;
		text-underline-offset: 0.18em;
		text-decoration-color: rgb(22 163 74 / 1);
	}

	:global(.dark) .post-inline-diff-add-target {
		text-decoration-color: rgb(134 239 172 / 1);
	}

	.post-inline-diff-add-target-img {
		outline: 2px solid rgb(22 163 74 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
	}

	:global(.dark) .post-inline-diff-add-target-img {
		outline-color: rgb(134 239 172 / 1);
	}

	.post-inline-diff-del-line {
		margin: 0.5rem 0;
		color: rgb(220 38 38 / 1);
	}

	:global(.dark) .post-inline-diff-del-line {
		color: rgb(252 165 165 / 1);
	}

	.post-inline-diff-del-line del {
		text-decoration-thickness: 2px;
	}

	.post-inline-diff-add-line {
		margin: 0.5rem 0;
		color: rgb(22 163 74 / 1);
	}

	:global(.dark) .post-inline-diff-add-line {
		color: rgb(134 239 172 / 1);
	}

	.post-inline-diff-add-line .post-inline-diff-add-content {
		display: inline-block;
		vertical-align: top;
		text-decoration-line: underline;
		text-decoration-thickness: 2px;
	}

	.post-inline-diff-add-line img,
	.post-inline-diff-add-content img {
		outline: 2px solid rgb(22 163 74 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
		background-color: rgba(22, 163, 74, 0.1);
	}

	:global(.dark) .post-inline-diff-add-line img,
	:global(.dark) .post-inline-diff-add-content img {
		outline-color: rgb(134 239 172 / 1);
		background-color: rgba(134, 239, 172, 0.1);
	}

	.post-inline-diff-del-line.post-inline-diff-del-line {
		list-style: none;
	}

	.post-inline-diff-del-line img,
	.post-inline-diff-del-line del img {
		outline: 2px solid rgb(220 38 38 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
		opacity: 0.8;
	}

	:global(.dark) .post-inline-diff-del-line img,
	:global(.dark) .post-inline-diff-del-line del img {
		outline-color: rgb(252 165 165 / 1);
	}

	.post-inline-diff-del-target {
		color: rgb(220 38 38 / 1);
		text-decoration-line: line-through;
		text-decoration-thickness: 2px;
	}

	:global(.dark) .post-inline-diff-del-target {
		color: rgb(252 165 165 / 1);
	}

	.post-inline-diff-del-target-img {
		outline: 2px solid rgb(220 38 38 / 1);
		outline-offset: 2px;
		border-radius: 0.5rem;
	}

	:global(.dark) .post-inline-diff-del-target-img {
		outline-color: rgb(252 165 165 / 1);
	}
</style>
