---
import { Icon } from "astro-icon/components";
---

<style>
    #notification-panel {
        position: relative;
        width: 3.75rem;
        height: 3.75rem;
        border-radius: 50%;
        overflow: hidden;
        box-sizing: border-box;
        transition:
            width 360ms cubic-bezier(0.4, 0, 0.2, 1),
            height 360ms cubic-bezier(0.4, 0, 0.2, 1),
            border-radius 360ms cubic-bezier(0.4, 0, 0.2, 1),
            transform 260ms cubic-bezier(0.34, 1.56, 0.64, 1),
            opacity 260ms ease;
    }
    #notification-panel.is-open {
        width: var(--np-open-width, min(20rem, calc(100vw - 2rem)));
        height: var(--np-open-height, min(70vh, 34rem));
        border-radius: 1rem;
    }
    #notification-minimized {
        position: absolute;
        inset: 0;
        transition: opacity 160ms ease, transform 260ms cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    #notification-content {
        position: absolute;
        inset: 0;
        opacity: 0;
        pointer-events: none;
        transform: translateY(8px);
        transition: opacity 200ms ease, transform 260ms ease;
    }
    #notification-panel.is-open #notification-minimized {
        opacity: 0;
        pointer-events: none;
        transform: none;
    }
    #notification-panel.is-open-content #notification-content {
        opacity: 1;
        pointer-events: auto;
        transform: translateY(0);
    }
</style>

<div id="new-post-notification" class="fixed bottom-4 right-4 z-50 pointer-events-none">
    <div id="notification-panel" class="pointer-events-auto bg-[var(--card-bg)] border-2 border-[var(--primary)] text-[var(--primary)] shadow-lg transform translate-y-20 opacity-0">
        <button id="notification-minimized" aria-label="New post notification" class="flex items-center justify-center">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 8a6 6 0 0 1 12 0c0 7 3 9 3 9H3s3-2 3-9"></path><path d="M10.3 21a1.94 1.94 0 0 0 3.4 0"></path></svg>
        </button>

        <div id="notification-content" class="flex flex-col p-5">
            <div class="flex items-center justify-between mb-3">
                <div class="flex items-center gap-2 text-[var(--primary)]">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg>
                    <h3 class="font-bold text-black dark:text-white">发现新文章</h3>
                    <a href="/posts/post-diff-guide/#食用方法" class="ml-1 text-xs text-[var(--primary)] hover:underline opacity-80" title="查看食用方法">
                        <Icon name="material-symbols:help-outline-rounded" size={16} />
                    </a>
                </div>
                <div class="flex items-center gap-1">
                    <button id="clear-notification" class="text-black/50 dark:text-white/50 hover:text-red-500 transition-colors p-1 rounded-md hover:bg-red-500/10" title="清空通知">
                        <Icon name="material-symbols:delete-rounded" size={18} class="mx-auto" />
                    </button>
                    <button id="minimize-notification" class="text-black/50 dark:text-white/50 hover:text-[var(--primary)] transition-colors p-1 rounded-md hover:bg-[var(--primary)]/10" title="隐藏">
                        <Icon name="material-symbols:close-rounded" size={18} class="mx-auto" />
                    </button>
                </div>
            </div>
            <div id="new-post-list" class="text-sm text-black/80 dark:text-white/80 transition-colors space-y-3 flex-1 overflow-y-auto overflow-x-hidden"></div>
        </div>
    </div>
    <span id="notification-dot" class="absolute top-0 right-0 w-3 h-3 bg-red-500 rounded-full border-2 border-[var(--card-bg)] animate-pulse pointer-events-none transform translate-y-20 opacity-0 scale-0 transition-all duration-260 ease-out"></span>
</div>

<script>
    import * as Diff from 'diff';

    (async function() {
    const sp = new URLSearchParams(window.location.search);
    if (sp.get('__diff_debug_cleanup') === '1') {
        try {
            indexedDB.deleteDatabase('fuwari-rss-store');
        } catch {
        }
        try {
            const url = new URL(window.location.href);
            url.searchParams.delete('__diff_debug_cleanup');
            history.replaceState({}, '', `${url.pathname}${url.search}${url.hash}`);
        } catch {
        }
        return;
    }
    if (sp.get('__diff_debug') === '1') return;
    const DB_NAME = 'fuwari-rss-store';
    const DB_VERSION = 3; 
    const STORE_NAME = 'posts';
    const LOCAL_STORAGE_KEY = 'blog-posts-cache'; 
    const NOTIFICATION_ID = 'new-post-notification';
    const LIST_ID = 'new-post-list';
    
    // Compute a context-aware ID for the current site/path
    const BASE_PATH = (import.meta.env.BASE_URL ?? '/');
    const SCOPE_ID = BASE_PATH.replace(/^\/+|\/+$/g, '') || 'root';

    // IndexedDB Helpers
    function openDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (db.objectStoreNames.contains(STORE_NAME)) {
                    const existingStore = event.target.transaction.objectStore(STORE_NAME);
                    if (existingStore.keyPath !== 'id') {
                        db.deleteObjectStore(STORE_NAME);
                        db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                    }
                    return;
                }
                db.createObjectStore(STORE_NAME, { keyPath: 'id' });
            };
        });
    }

    function normalizeGuid(guid, link) {
        const value = (guid || link || '').trim();
        if (!value) return '';
        try {
            const url = new URL(value, window.location.origin);
            return `${url.pathname}${url.search}${url.hash}`;
        } catch {
            return value;
        }
    }

    function generateId(guid) {
        // Create a unique ID combining the scope (pathname root) and the article guid
        return `${SCOPE_ID}:${guid}`;
    }

    function getStoredPosts(db) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
        });
    }

    function savePosts(db, posts) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            posts.forEach(post => {
                // Ensure we save with the scoped ID
                const itemToSave = { ...post, id: generateId(post.guid) };
                store.put(itemToSave);
            });
            
            transaction.oncomplete = () => resolve();
            transaction.onerror = () => reject(transaction.error);
        });
    }

    // Helper to get current RSS items
    async function fetchRSS() {
        try {
            const response = await fetch('/rss.xml', { cache: 'no-store' });
            const text = await response.text();
            const parser = new DOMParser();
            const xml = parser.parseFromString(text, 'text/xml');
            const items = Array.from(xml.querySelectorAll('item'));
            
            return items.map(item => {
                const title = item.querySelector('title')?.textContent || '';
                const link = (item.querySelector('link')?.textContent || '').trim();
                const rawGuid = (item.querySelector('guid')?.textContent || '').trim();
                const guid = normalizeGuid(rawGuid || link, link);
                const pubDate = new Date(item.querySelector('pubDate')?.textContent || '').getTime();
                const description = item.querySelector('description')?.textContent || '';
                
                // Try to get content from multiple possible sources to ensure we capture it
                const contentEncoded = item.getElementsByTagNameNS('http://purl.org/rss/1.0/modules/content/', 'encoded')[0]?.textContent;
                const content = contentEncoded || 
                                item.getElementsByTagName('content:encoded')[0]?.textContent || 
                                item.querySelector('content')?.textContent || '';

                return {
                    title,
                    link,
                    guid,
                    pubDate,
                    description,
                    content // Full content is stored here
                };
            });
        } catch (e) {
            console.error('Failed to fetch RSS:', e);
            return [];
        }
    }

    // Helper to compute raw diff (keep <content:encoded> HTML to preserve images)
    function computeDiff(oldText, newText) {
        if (!oldText || !newText) return null;

        const normalizeRaw = (text) => {
            const s = String(text || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
            const lines = s.split("\n").map((line) => line.replace(/[ \t]+$/g, ""));
            return lines.join("\n").trim();
        };

        const normalizeForDiffHtml = (html) => {
            const raw = normalizeRaw(html);
            if (!raw) return "";
            const parser = new DOMParser();
            const doc = parser.parseFromString(`<div>${raw}</div>`, "text/html");
            const root = doc.body.firstElementChild;
            if (!root) return raw;

            const lines = [];
            for (const el of Array.from(root.children)) {
                const htmlLine = String(el.outerHTML || "")
                    .replace(/\r\n/g, "\n")
                    .replace(/\r/g, "\n")
                    .replace(/\n+/g, " ")
                    .replace(/[ \t]+/g, " ")
                    .trim();
                if (!htmlLine) continue;
                lines.push(htmlLine);
            }

            return lines.join("\n");
        };

        const cleanOld = normalizeForDiffHtml(oldText);
        const cleanNew = normalizeForDiffHtml(newText);

        if (!cleanOld || !cleanNew) return null;

        // Use 'diff' library to compute line-by-line diff
        const diffs = Diff.diffLines(cleanOld, cleanNew);
        
        const hasChanges = diffs.some(part => part.added || part.removed);
        
        if (!hasChanges) return null;

        return diffs;
    }

    function escapeHtml(text) {
        if (!text) return text;
        return text
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    // Helper to show notification
    function showNotification(newPosts, timestamp, isFresh, initTime) {
        const minimizedBtn = document.getElementById('notification-minimized');
        const panel = document.getElementById('notification-panel');
        const list = document.getElementById(LIST_ID);
        const dot = document.getElementById('notification-dot');
        const minimizeBtn = document.getElementById('minimize-notification');
        const clearBtn = document.getElementById('clear-notification');
        const NOTIFICATION_STATE_KEY = 'fuwari-notification-state';
        const INIT_TIME_KEY = 'fuwari-notification-init-time';
        
        if (!minimizedBtn || !panel || !list) return;
        
        requestAnimationFrame(() => {
            panel.classList.remove('translate-y-20', 'opacity-0');
            dot?.classList.remove('translate-y-20', 'opacity-0');
        });

        const initTimeStr = new Date(initTime).toLocaleString();
        const checkTimeStr = new Date(timestamp).toLocaleString();

        // Logic for "No updates"
        if (newPosts.length === 0) {
             list.innerHTML = `<div class="text-center text-gray-500 dark:text-gray-400 py-4">
                <p class="text-sm font-medium mb-2">暂无文章更新</p>
                <div class="text-xs opacity-70 bg-gray-100 dark:bg-gray-800 rounded px-2 py-1 inline-block">
                    ${initTimeStr} - ${checkTimeStr}
                </div>
             </div>`;
             dot?.classList.add('scale-0');
             
             // Setup event listeners even if no posts (so it can be opened)
             setupEventListeners();
             return;
        }
        
        // Show timestamp header
        let html = `
            <div class="text-xs text-gray-500 dark:text-gray-400 mb-2 px-1 flex flex-col gap-0.5">
                <div class="font-medium">发现更新</div>
                <div class="opacity-70 text-[10px]">${initTimeStr} - ${checkTimeStr}</div>
            </div>`;
        
        newPosts.forEach(post => {
            const isUpdated = post.isUpdated;
            const badge = isUpdated 
                ? '<span class="text-xs bg-blue-100 dark:bg-blue-900 text-blue-600 dark:text-blue-300 px-1.5 py-0.5 rounded ml-2">更新</span>'
                : '<span class="text-xs bg-green-100 dark:bg-green-900 text-green-600 dark:text-green-300 px-1.5 py-0.5 rounded ml-2">新文章</span>';
            
            // Convert absolute URL to relative path
            let postLink = post.link;
            try {
                const url = new URL(post.link);
                postLink = url.pathname;
            } catch {
                // Keep original if not a valid URL
            }

            let postHref = postLink;
            if (isUpdated && post.diff) {
                try {
                    const url = new URL(postLink, window.location.origin);
                    url.searchParams.set('diff', '1');
                    url.hash = 'post-diff';
                    postHref = `${url.pathname}${url.search}${url.hash}`;
                } catch {
                    const base = postLink.split('#')[0];
                    postHref = base.includes('?') ? `${base}&diff=1#post-diff` : `${base}?diff=1#post-diff`;
                }
            }

            html += `
            <div class="mb-4 last:mb-0">
                <div class="flex items-center justify-between p-3 rounded-lg hover:bg-[var(--primary)]/5 transition-colors">
                    <a href="${postHref}" class="font-medium truncate pr-2 hover:text-[var(--primary)] transition-colors text-black dark:text-white block flex-1">
                        ${post.title}
                    </a>
                    <div class="flex items-center shrink-0">
                        ${badge}
                    </div>
                </div>
            </div>`;
        });

        list.innerHTML = html;
        
        // Show red dot if there are any posts with changes
        if (newPosts.length > 0) {
             dot?.classList.remove('scale-0');
             // Auto-open panel only on first detection (isFresh)
             if (isFresh) {
                 setTimeout(() => {
                     openPanel();
                 }, 1500);
             }
        } else {
             dot?.classList.add('scale-0');
        }

        setupEventListeners();

        function updatePanelTargetSize() {
            const rootFontSize = Number.parseFloat(getComputedStyle(document.documentElement).fontSize) || 16
            const maxPanelWidthPx = Math.min(20 * rootFontSize, window.innerWidth - 32)
            const minPanelWidthPx = Math.min(16 * rootFontSize, window.innerWidth - 32)

            let longestTitle = 0
            for (const post of newPosts) {
                if (!post?.title) continue
                longestTitle = Math.max(longestTitle, String(post.title).length)
            }

            const estimatedWidthRem = 14 + Math.min(longestTitle, 30) * 0.2
            const estimatedWidthPx = estimatedWidthRem * rootFontSize
            const openWidthPx = Math.max(minPanelWidthPx, Math.min(maxPanelWidthPx, estimatedWidthPx))
            panel.style.setProperty('--np-open-width', `${Math.round(openWidthPx)}px`)

            const sizer = document.createElement('div')
            sizer.style.position = 'fixed'
            sizer.style.left = '-10000px'
            sizer.style.top = '0'
            sizer.style.width = `${Math.round(openWidthPx)}px`
            sizer.style.maxHeight = 'none'
            sizer.style.overflow = 'visible'
            sizer.style.pointerEvents = 'none'
            sizer.style.visibility = 'hidden'

            const content = document.getElementById('notification-content')
            if (!content) return
            const clone = content.cloneNode(true)
            if (clone instanceof HTMLElement) {
                clone.style.position = 'static'
                clone.style.inset = 'auto'
                clone.style.opacity = '1'
                clone.style.pointerEvents = 'auto'
                clone.style.transform = 'none'
                clone.querySelectorAll('[id]').forEach(el => el.removeAttribute('id'))
                const listEl = clone.querySelector('#new-post-list')
                if (listEl instanceof HTMLElement) {
                    listEl.style.maxHeight = 'none'
                    listEl.style.overflow = 'visible'
                }
            }

            sizer.appendChild(clone)
            document.body.appendChild(sizer)
            const measuredHeightPx = (clone instanceof HTMLElement ? clone.scrollHeight : sizer.scrollHeight) + 4
            sizer.remove()

            const maxPanelHeightPx = Math.min(window.innerHeight * 0.7, 34 * rootFontSize)
            const minPanelHeightPx = 10 * rootFontSize
            const openHeightPx = Math.max(minPanelHeightPx, Math.min(maxPanelHeightPx, measuredHeightPx))
            panel.style.setProperty('--np-open-height', `${Math.round(openHeightPx)}px`)
        }

        function openPanel() {
            updatePanelTargetSize()
            panel.classList.add('is-open');
            const prevTimer = panel.getAttribute('data-open-timer');
            if (prevTimer) {
                clearTimeout(Number(prevTimer));
            }
            const timer = window.setTimeout(() => {
                panel.classList.add('is-open-content');
                panel.removeAttribute('data-open-timer');
            }, 360);
            panel.setAttribute('data-open-timer', String(timer));
        }

        function closePanel() {
            const prevTimer = panel.getAttribute('data-open-timer');
            if (prevTimer) {
                clearTimeout(Number(prevTimer));
                panel.removeAttribute('data-open-timer');
            }
            panel.classList.remove('is-open-content');
            panel.classList.remove('is-open');
        }

        function setupEventListeners() {
            minimizedBtn.onclick = () => {
                if (!panel.classList.contains('is-open')) {
                    openPanel();
                } else {
                    closePanel();
                }
            };
    
            minimizeBtn.onclick = (e) => {
                e.stopPropagation();
                closePanel();
            };

            if (clearBtn) {
                clearBtn.onclick = (e) => {
                    e.stopPropagation();
                    localStorage.removeItem(NOTIFICATION_STATE_KEY);
                    
                    const now = Date.now();
                    localStorage.setItem(INIT_TIME_KEY, now.toString());
                    
                    showNotification([], now, false, now);
                };
            }
    
            if (!list.hasAttribute('data-listening')) {
                list.setAttribute('data-listening', 'true');
            }

            if (!panel.hasAttribute('data-resize-listening')) {
                window.addEventListener('resize', () => {
                    if (!panel.classList.contains('is-open')) return
                    updatePanelTargetSize()
                })
                panel.setAttribute('data-resize-listening', 'true')
            }
        }
        
        // Auto-open panel on first load if it's high priority? 
         // Or keep it minimized to be less intrusive?
         // Let's auto-open it briefly to catch attention, then user can minimize
     }

    // Main logic
    try {
        // Developer Mode Check
        const urlParams = new URLSearchParams(window.location.search);
        const isDevMode = urlParams.has('debug-notification');

        if (isDevMode) {
            console.log('[Notification] Developer mode active');
            const mockDiff = [
                { value: "This is some unchanged text context.\n", added: undefined, removed: undefined },
                { value: "This line was removed.\n", added: undefined, removed: true },
                { value: "This line is new.\n", added: true, removed: undefined },
                { value: "More unchanged text.\n", added: undefined, removed: undefined }
            ];
            
            const mockPosts = [
                { title: 'Test New Post 1', link: '#', guid: 'test-1', isUpdated: false },
                { 
                    title: 'Test Updated Post', 
                    link: '#', 
                    guid: 'test-2', 
                    isUpdated: true,
                    diff: mockDiff
                },
            ];
            showNotification(mockPosts, Date.now(), true, Date.now());
            return; 
        }

        const currentPosts = await fetchRSS();
        if (currentPosts.length === 0) return;

        const db = await openDB();
        const storedPosts = await getStoredPosts(db);
        const NOTIFICATION_STATE_KEY = 'fuwari-notification-state';
        const INIT_TIME_KEY = 'fuwari-notification-init-time';

        // Helper to get or set init time
        let initTimestamp = localStorage.getItem(INIT_TIME_KEY);
        if (!initTimestamp) {
            initTimestamp = Date.now().toString();
            localStorage.setItem(INIT_TIME_KEY, initTimestamp);
        }
        const initTime = parseInt(initTimestamp);

        // Migration from localStorage (Old cache)
        const localCache = localStorage.getItem(LOCAL_STORAGE_KEY);
        if (storedPosts.length === 0 && localCache) {
            console.log('[Notification] Migrating from localStorage...');
            // Just init DB and clear old cache
            await savePosts(db, currentPosts);
            localStorage.removeItem(LOCAL_STORAGE_KEY);
            // Treat as first visit (no updates)
            showNotification([], Date.now(), false, initTime); 
            return;
        }

        if (storedPosts.length === 0) {
            // First visit
            await savePosts(db, currentPosts);
            // Clear any stale notification state
            localStorage.removeItem(NOTIFICATION_STATE_KEY);
            showNotification([], Date.now(), false, initTime);
        } else {
            // Compare
            const storedMap = new Map(
                storedPosts.map(p => [p.id || generateId(p.guid || p.link || p.title), p])
            );
            
            const detectedChanges = [];

            currentPosts.forEach(post => {
                const stored = storedMap.get(generateId(post.guid));
                if (!stored) {
                    // New post
                    detectedChanges.push({ ...post, isUpdated: false });
                } else {
                    // Check for ANY change (Title, Description, Content)
                    const titleChanged = post.title !== stored.title;
                    const descriptionChanged = post.description !== stored.description;
                    const contentChanged = post.content !== stored.content;
                    
                    if (titleChanged || descriptionChanged || contentChanged) {
                        const result = {};
                        let hasChanges = false;
                        
                        if (contentChanged) {
                             const d = computeDiff(stored.content, post.content);
                             if (d) {
                                 result.content = d;
                                 hasChanges = true;
                             }
                        }
                        
                        if (descriptionChanged) {
                             const d = Diff.diffChars(stored.description, post.description);
                             if (d) {
                                 result.description = d;
                                 hasChanges = true;
                             }
                        }
                        
                        if (titleChanged) {
                             const d = Diff.diffChars(stored.title, post.title);
                             if (d) {
                                 result.title = d;
                                 hasChanges = true;
                             }
                        }
                        
                        if (hasChanges) {
                            detectedChanges.push({ 
                                ...post, 
                                isUpdated: true, 
                                diff: result,
                                diffType: 'composite'
                            });
                        }
                    }
                }
            });

            if (detectedChanges.length > 0) {
                // Intercept: If all posts in the feed are detected as new (likely due to ID change or cache issue), suppress notification
                const isAllNew = detectedChanges.length === currentPosts.length && detectedChanges.every(p => !p.isUpdated);
                // Also intercept if ALL posts are detected as updated (likely a full rebuild/re-hash of content without meaningful changes)
                const isAllUpdated = detectedChanges.length === currentPosts.length && detectedChanges.every(p => p.isUpdated);

                if (isAllNew || isAllUpdated) {
                    console.log('[Notification] Intercepted "all new/updated" posts scenario. Suppressing notification.');
                    // Update DB to sync with new state
                    await savePosts(db, currentPosts);
                    // Clear state
                    localStorage.removeItem(NOTIFICATION_STATE_KEY);
                    showNotification([], Date.now(), false, initTime);
                    return;
                }

                // CASE 1: New updates detected
                const timestamp = Date.now();
                // Persist notification state
                const state = {
                    timestamp: timestamp,
                    items: detectedChanges
                };
                localStorage.setItem(NOTIFICATION_STATE_KEY, JSON.stringify(state));
                
                // Update DB so we don't detect them again as "fresh" next time
                await savePosts(db, currentPosts);
                
                // Show with Red Dot + Auto Open
                showNotification(detectedChanges, timestamp, true, initTime);
            } else {
                // CASE 2: No new updates
                // Check if we have a persisted notification state
                const persistedStateStr = localStorage.getItem(NOTIFICATION_STATE_KEY);
                if (persistedStateStr) {
                    try {
                        const state = JSON.parse(persistedStateStr);
                        // Show persisted items, NO Red Dot, NO Auto Open
                        showNotification(state.items, state.timestamp, false, initTime);
                    } catch (e) {
                        console.error('Failed to parse notification state', e);
                        showNotification([], Date.now(), false, initTime);
                    }
                } else {
                    // No updates and no history -> "No updates"
                    showNotification([], Date.now(), false, initTime);
                }
            }
        }
    } catch (e) {
        console.error('New post check failed:', e);
    }
})();
</script>
